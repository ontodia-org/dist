// Generated by dts-bundle v0.5.0
// Dependencies for this module:
//   ../../react
//   ../../backbone
//   ../../jointjs

declare module 'ontodia' {
    export * from 'ontodia/ontodia/customization/props';
    export * from 'ontodia/ontodia/customization/defaultTemplate';
    export * from 'ontodia/ontodia/customization/templates/stringTemplates';
    export * from 'ontodia/ontodia/data/model';
    export * from 'ontodia/ontodia/data/provider';
    export * from 'ontodia/ontodia/data/demo/provider';
    export { RdfNode, RdfIri, RdfLiteral, Triple } from 'ontodia/ontodia/data/sparql/sparqlModels';
    export * from 'ontodia/ontodia/data/sparql/sparqlDataProvider';
    export * from 'ontodia/ontodia/data/sparql/sparqlDataProviderSettings';
    export * from 'ontodia/ontodia/data/sparql/graphBuilder';
    export * from 'ontodia/ontodia/data/sparql/sparqlGraphBuilder';
    export { Element, Link } from 'ontodia/ontodia/diagram/elements';
    export { LayoutData, LayoutCell, LayoutElement, LayoutLink } from 'ontodia/ontodia/diagram/layoutData';
    export * from 'ontodia/ontodia/diagram/model';
    export * from 'ontodia/ontodia/diagram/view';
    export { Workspace, Props as WorkspaceProps } from 'ontodia/ontodia/workspace/workspace';
}

declare module 'ontodia/ontodia/customization/props' {
    import { ComponentClass } from 'react';
    import { Dictionary, Property } from 'ontodia/ontodia/data/model';
    export type TypeStyleResolver = (types: string[]) => CustomTypeStyle | undefined;
    export type LinkStyleResolver = (type: string) => LinkStyle | undefined;
    export type TemplateResolver = (types: string[]) => ElementTemplate | undefined;
    export interface CustomTypeStyle {
        color?: string;
        icon?: string;
    }
    export type ElementTemplate = ComponentClass<TemplateProps> | string;
    export interface TemplateProps {
        types: string;
        label: string;
        color: any;
        icon: string;
        iri: string;
        imgUrl?: string;
        isExpanded?: boolean;
        propsAsList?: PropArray;
        props?: Dictionary<Property>;
    }
    export type PropArray = Array<{
        id: string;
        name: string;
        property: Property;
    }>;
    export interface LinkStyle {
        connection?: {
            fill?: string;
            stroke?: string;
            'stroke-width'?: number;
            'stroke-dasharray'?: string;
        };
        markerSource?: LinkMarkerStyle;
        markerTarget?: LinkMarkerStyle;
        labels?: LinkLabelStyle[];
        connector?: {
            name?: string;
            args?: {
                radius?: number;
            };
        };
        router?: {
            name?: string;
            args?: {
                startDirections?: string[];
                endDirections?: string[];
                excludeTypes?: string[];
            };
        };
    }
    export interface LinkMarkerStyle {
        fill?: string;
        stroke?: string;
        strokeWidth?: string;
        d?: string;
        width?: number;
        height?: number;
    }
    export interface LinkLabelStyle {
        position?: number;
        attrs?: {
            rect?: {
                fill?: string;
                'stroke'?: string;
                'stroke-width'?: number;
            };
            text?: {
                fill?: string;
                'stroke'?: string;
                'stroke-width'?: number;
            };
        };
    }
}

declare module 'ontodia/ontodia/customization/defaultTemplate' {
    import * as React from 'react';
    import { TemplateProps } from 'ontodia/ontodia/customization/props';
    export class DefaultTemplate extends React.Component<TemplateProps, {}> {
        render(): JSX.Element;
    }
}

declare module 'ontodia/ontodia/customization/templates/stringTemplates' {
    export const DefaultElementTemplate: string;
    export const LeftBarTemplate: string;
    export const BigIconTemplate: string;
    export const PersonTemplate: string;
    export const OrganizationTemplate: string;
}

declare module 'ontodia/ontodia/data/model' {
    export type Dictionary<T> = {
        [key: string]: T;
    };
    export interface LocalizedString {
        text: string;
        lang: string;
    }
    export type Property = {
        type: 'string';
        values: LocalizedString[];
    };
    export interface ElementModel {
        id: string;
        types: string[];
        label: {
            values: LocalizedString[];
        };
        image?: string;
        properties: {
            [id: string]: Property;
        };
    }
    export interface LinkModel {
        linkTypeId: string;
        sourceId: string;
        targetId: string;
    }
    export interface ClassModel {
        id: string;
        label: {
            values: LocalizedString[];
        };
        count: number;
        children: ClassModel[];
    }
    export interface LinkCount {
        id: string;
        inCount: number;
        outCount: number;
    }
    export interface LinkType {
        id: string;
        label: {
            values: LocalizedString[];
        };
        count: number;
    }
    export interface PropertyModel {
        id: string;
        label: {
            values: LocalizedString[];
        };
    }
}

declare module 'ontodia/ontodia/data/provider' {
    import { Dictionary, ClassModel, LinkType, ElementModel, LinkModel, LinkCount, PropertyModel } from 'ontodia/ontodia/data/model';
    /**
        * DataProvider is responsible for getting data into Ontodia
        *
        * It has three parts:
        *  - Schema extraction - classTree(), linkTypes()
        *  - On-demand schema extraction - classInfo(), propertyInfo(), linkTypeInfo()
        *  - elements and links extraction - elementsInfo() and linksInfo()
        *  - navigation - linkTypesOf(), linkElements()
        *  - filtering - filter
        *
        *  Schema extraction is executed on initialization and used to display class tree.
        *
        *  On-demand schema extraction occurs when element with yet unknown type or link type appears any part of Ontodia.
        *
        *  Elements and links extraction is executed when new element is placed on the diagram or diagram is restored from
        *  saved state to get all the data for it
        *
        *  Navigation functions are called when user brings up navigation menu to display available links
        *  and places chosen elements on the diagram.
        *
        *  When possible, Ontodia will group requests into batches to reduce round-trips and this will reduce calls to
        *  data provider.
        *
        */
    export interface DataProvider {
            /** should return start-up class tree. In case of huge class tree some limits should be imposed.
                * It can contain count of instances for each class if it's possible to get it from source.
                */
            classTree(): Promise<ClassModel[]>;
            linkTypes(): Promise<LinkType[]>;
            /**
                * Class information
                */
            classInfo(params: {
                    classIds: string[];
            }): Promise<ClassModel[]>;
            /**
                * Data properties information
                */
            propertyInfo?(params: {
                    propertyIds: string[];
            }): Promise<Dictionary<PropertyModel>>;
            /**
                * Link type information.
                */
            linkTypesInfo(params: {
                    linkTypeIds: string[];
            }): Promise<LinkType[]>;
            /**
                * Getting the elements from the data source on diagram initialization and on navigation events
                */
            elementInfo(params: {
                    elementIds: string[];
            }): Promise<Dictionary<ElementModel>>;
            /**
                * Should return all links between elements.
                * linkTypeIds is ignored in current sparql providers and is subject to be removed
                */
            linksInfo(params: {
                    elementIds: string[];
                    linkTypeIds: string[];
            }): Promise<LinkModel[]>;
            /**
                * Get link types of element to build navigation menu
                */
            linkTypesOf(params: {
                    elementId: string;
            }): Promise<LinkCount[]>;
            /**
                * returns elements following link for specified element.
                * Has overlapping functionality with filter, but easier less powerful and easier to implement
                * linkId could be null, if it's the case method should return all elements from all links from current element.
                */
            linkElements(params: {
                    elementId: string;
                    linkId: string;
                    limit: number;
                    offset: number;
                    direction?: 'in' | 'out';
            }): Promise<Dictionary<ElementModel>>;
            /**
                * Supports filter functionality with different filters - by type, by element and it's connection, by full-text search
                * Implementation should implement all possible combinations
                */
            filter(params: FilterParams): Promise<Dictionary<ElementModel>>;
    }
    export default DataProvider;
    export interface FilterParams {
            /**
                * element type filter
                */
            elementTypeId?: string;
            /**
                * text search
                */
            text?: string;
            /**
                * Reference element id to limit elements accessible through links from this elements only.
                * Could be used with refElementLinkId to limit link types which to follow.
                */
            refElementId?: string;
            /**
                * Reference element link type id. Is used only when refElementId is set.
                */
            refElementLinkId?: string;
            /**
                * Reference element link type direction ('in' | 'out'). Is used only when refElementLinkId is set.
                */
            linkDirection?: 'in' | 'out';
            /**
                * Limit number of elements returned. Defaults depend on data provider implementation
                */
            limit: number;
            /**
                * Offset within matched data set to use
                */
            offset: number;
            /**
                * Right now this is unused in sparql data provider.
                * It was introduced to order results by particular language when doing substring match with regexps.
                * It's subject to be removed.
                */
            languageCode: string;
    }
}

declare module 'ontodia/ontodia/data/demo/provider' {
    import { DataProvider, FilterParams } from 'ontodia/ontodia/data/provider';
    import { Dictionary, ClassModel, LinkType, ElementModel, LinkModel } from 'ontodia/ontodia/data/model';
    export class DemoDataProvider implements DataProvider {
        classTree(): Promise<ClassModel[]>;
        classInfo(params: {
            classIds: string[];
        }): Promise<ClassModel[]>;
        linkTypes(): Promise<LinkType[]>;
        linkTypesInfo(params: {
            linkTypeIds: string[];
        }): Promise<LinkType[]>;
        elementInfo(params: {
            elementIds: string[];
        }): Promise<Dictionary<ElementModel>>;
        linksInfo(params: {
            elementIds: string[];
            linkTypeIds: string[];
        }): Promise<LinkModel[]>;
        linkTypesOf(params: {
            elementId: string;
        }): Promise<{}[]>;
        linkElements(params: {
            elementId: string;
            linkId: string;
            limit: number;
            offset: number;
            direction?: 'in' | 'out';
        }): Promise<Dictionary<ElementModel>>;
        filter(params: FilterParams): Promise<Dictionary<ElementModel>>;
    }
}

declare module 'ontodia/ontodia/data/sparql/sparqlModels' {
    export type RdfNode = RdfIri | RdfLiteral;
    export interface RdfIri {
        type: 'uri';
        value: string;
    }
    export interface RdfLiteral {
        type: 'literal';
        value: string;
        datatype?: string;
        'xml:lang': string;
    }
    export interface Triple {
        subject: RdfNode;
        predicate: RdfNode;
        object: RdfNode;
    }
    export interface ElementBinding {
        inst: RdfLiteral;
        class?: RdfLiteral;
        label?: RdfLiteral;
        propType?: RdfLiteral;
        propValue?: RdfLiteral;
    }
    export interface ClassBinding {
        class: RdfIri;
        instcount?: RdfLiteral;
        label?: RdfLiteral;
        parent?: RdfIri;
    }
    export interface PropertyBinding {
        prop: RdfIri;
        label?: RdfLiteral;
    }
    export interface LinkBinding {
        source: RdfIri;
        type: RdfIri;
        target: RdfIri;
    }
    export interface LinkCountBinding {
        link: RdfIri;
        inCount: RdfLiteral;
        outCount: RdfLiteral;
    }
    export interface LinkTypeInfoBinding {
        link: RdfIri;
        label?: RdfLiteral;
        instcount?: RdfLiteral;
    }
    export interface ElementImageBinding {
        inst: RdfIri;
        linkType: RdfIri;
        image: RdfIri;
    }
    export interface SparqlResponse<Binding> {
        head: {
            vars: string[];
        };
        results: {
            bindings: Binding[];
        };
    }
}

declare module 'ontodia/ontodia/data/sparql/sparqlDataProvider' {
    import 'whatwg-fetch';
    import { DataProvider, FilterParams } from 'ontodia/ontodia/data/provider';
    import { Dictionary, ClassModel, LinkType, ElementModel, LinkModel, LinkCount, PropertyModel } from 'ontodia/ontodia/data/model';
    import { SparqlResponse, Triple } from 'ontodia/ontodia/data/sparql/sparqlModels';
    import { SparqlDataProviderSettings } from 'ontodia/ontodia/data/sparql/sparqlDataProviderSettings';
    export enum SparqlQueryMethod {
            GET = 1,
            POST = 2,
    }
    /**
        * Runtime settings of SPARQL data provider
        */
    export interface SparqlDataProviderOptions {
            /**
                *  sparql endpoint URL to use
                */
            endpointUrl: string;
            /**
                * properties to use as image URLs
                */
            imagePropertyUris?: string[];
            /**
                * you can specify prepareImages function to extract image URL from element model
                */
            prepareImages?: (elementInfo: Dictionary<ElementModel>) => Promise<Dictionary<string>>;
            /**
                * wether to use GET (more compatible (Virtuozo), more error-prone due to large request URLs)
                * or POST(less compatible, better on large data sets)
                */
            queryMethod?: SparqlQueryMethod;
            labelProperty?: string;
    }
    export class SparqlDataProvider implements DataProvider {
            dataLabelProperty: string;
            constructor(options: SparqlDataProviderOptions, settings?: SparqlDataProviderSettings);
            classTree(): Promise<ClassModel[]>;
            propertyInfo(params: {
                    propertyIds: string[];
            }): Promise<Dictionary<PropertyModel>>;
            classInfo(params: {
                    classIds: string[];
            }): Promise<ClassModel[]>;
            linkTypesInfo(params: {
                    linkTypeIds: string[];
            }): Promise<LinkType[]>;
            linkTypes(): Promise<LinkType[]>;
            elementInfo(params: {
                    elementIds: string[];
            }): Promise<Dictionary<ElementModel>>;
            linksInfo(params: {
                    elementIds: string[];
                    linkTypeIds: string[];
            }): Promise<LinkModel[]>;
            linkTypesOf(params: {
                    elementId: string;
            }): Promise<LinkCount[]>;
            linkElements(params: {
                    elementId: string;
                    linkId: string;
                    limit: number;
                    offset: number;
                    direction?: 'in' | 'out';
            }): Promise<Dictionary<ElementModel>>;
            filter(params: FilterParams): Promise<Dictionary<ElementModel>>;
            executeSparqlQuery<Binding>(query: string): Promise<SparqlResponse<Binding>>;
            executeSparqlConstruct(query: string): Promise<Triple[]>;
    }
    export function executeSparqlQuery<Binding>(endpoint: string, query: string, method: SparqlQueryMethod): Promise<SparqlResponse<Binding>>;
    export function executeSparqlConstruct(endpoint: string, query: string, method: SparqlQueryMethod): Promise<Triple[]>;
    export default SparqlDataProvider;
}

declare module 'ontodia/ontodia/data/sparql/sparqlDataProviderSettings' {
    /**
        * this is dataset-schema specific settings
        */
    export interface SparqlDataProviderSettings {
            /**
                * default prefix to be used in every query
                */
            defaultPrefix: string;
            /**
                *  property to use as label in schema (classes, properties)
                */
            schemaLabelProperty: string;
            /**
                * property to use as instance label
                * todo: make it an array
                */
            dataLabelProperty: string;
            /**
                * full-text search settings
                */
            fullTextSearch: FullTextSearchSettings;
            /**
                * query to retreive class tree. Should return class, label, parent, instcount (optional)
                */
            classTreeQuery: string;
            /**
                * link types pattern - what to consider a link on initial fetch
                */
            linkTypesPattern: string;
            /**
                * query for fetching all information on element: labels, classes, properties
                */
            elementInfoQuery: string;
            /**
                * this should return image URL for ?inst as instance and ?linkType for image property IRI
                * todo: move to runtime settings instead? proxying is runtime thing
                */
            imageQueryPattern: string;
            /**
                * link types of returns possible link types from specified instance with statistics
                */
            linkTypesOfQuery: string;
            /**
                * when fetching all links from element, we could specify additional filter
                */
            filterRefElementLinkPattern: string;
            /**
                * filter by type pattern. One could use transitive type resolution here.
                */
            filterTypePattern: string;
            /**
                * how to fetch elements info when fetching data.
                */
            filterElementInfoPattern: string;
            /**
                * imposes additional filtering on elements within filter
                */
            filterAdditionalRestriction: string;
    }
    /**
        * Full text search settings,
        * developer could use anything from search extensions of triplestore to regular expressions match
        * See wikidata and dbpedia examples for reusing full text search capabilities of Blazegraph and Virtuozo
        */
    export interface FullTextSearchSettings {
            /**
                * prefix to use in FTS queries
                */
            prefix: string;
            /**
                * query pattern should return ?inst and ?score for given ${text}.
                */
            queryPattern: string;
            /**
                * try to extract label from IRI for usage in search purposes.
                * If you have no labels in the dataset and want to search, you
                * can use ?extractedLabel as something to search for.
                */
            extractLabel?: boolean;
    }
    export const WikidataSettings: SparqlDataProviderSettings;
    export const OWLRDFSSettings: SparqlDataProviderSettings;
    export const OWLStatsSettings: SparqlDataProviderSettings;
    export const DBPediaSettings: SparqlDataProviderSettings;
}

declare module 'ontodia/ontodia/data/sparql/graphBuilder' {
    import { LayoutData } from 'ontodia/ontodia/diagram/layoutData';
    import { Dictionary, ElementModel, LinkModel } from 'ontodia/ontodia/data/model';
    import { DataProvider } from 'ontodia/ontodia/data/provider';
    export class GraphBuilder {
        dataProvider: DataProvider;
        constructor(dataProvider: DataProvider);
        createGraph(graph: {
            elementIds: string[];
            links: LinkModel[];
        }): Promise<{
            preloadedElements: Dictionary<ElementModel>;
            layoutData: LayoutData;
        }>;
    }
    export default GraphBuilder;
}

declare module 'ontodia/ontodia/data/sparql/sparqlGraphBuilder' {
    import { SparqlDataProvider } from 'ontodia/ontodia/data/sparql/sparqlDataProvider';
    import { Triple } from 'ontodia/ontodia/data/sparql/sparqlModels';
    import { LayoutData } from 'ontodia/ontodia/diagram/layoutData';
    import { Dictionary, ElementModel } from 'ontodia/ontodia/data/model';
    import { GraphBuilder } from 'ontodia/ontodia/data/sparql/graphBuilder';
    export class SparqlGraphBuilder {
        dataProvider: SparqlDataProvider;
        graphBuilder: GraphBuilder;
        constructor(dataProvider: SparqlDataProvider);
        getGraphFromConstruct(constructQuery: string): Promise<{
            preloadedElements: Dictionary<ElementModel>;
            layoutData: LayoutData;
        }>;
        getGraphFromRDFGraph(graph: Triple[]): Promise<{
            preloadedElements: Dictionary<ElementModel>;
            layoutData: LayoutData;
        }>;
    }
}

declare module 'ontodia/ontodia/diagram/elements' {
    import * as Backbone from 'backbone';
    import * as joint from 'jointjs';
    import { ClassModel, ElementModel, LocalizedString } from 'ontodia/ontodia/data/model';
    import { DiagramModel, PreventLinksLoading } from 'ontodia/ontodia/diagram/model';
    export class UIElement extends joint.shapes.basic.Generic {
            markup: string;
            defaults(): any;
    }
    /**
        * Properties:
        *     isExpanded: boolean
        *     position: { x: number, y: number }
        *     size: { width: number, height: number }
        *     angle: number - degrees
        *
        * Events:
        *     state:loaded
        *     add-to-filter
        *     focus-on-me
        *     action:iriClick
        */
    export class Element extends UIElement {
            template: ElementModel;
            /** All in and out links of the element */
            links: Link[];
            isExpanded: boolean;
            initialize(): void;
            addToFilter(linkType?: FatLinkType, direction?: 'in' | 'out'): void;
            focus(): void;
            iriClick(iri: string): void;
    }
    /**
        * Properties:
        *     id: string
        *     label: { values: LocalizedString[] }
        *     count: number
        */
    export class FatClassModel extends Backbone.Model {
            model: ClassModel;
            readonly label: {
                    values: LocalizedString[];
            };
            constructor(classModel: ClassModel);
    }
    /**
        * Properties:
        *     id: string
        *     label: { values: LocalizedString[] }
        */
    export class RichProperty extends Backbone.Model {
            readonly label: {
                    values: LocalizedString[];
            };
            constructor(model: {
                    id: string;
                    label: {
                            values: LocalizedString[];
                    };
            });
    }
    /**
        * Properties:
        *     typeId: string
        *     typeIndex: number
        *     source: { id: string }
        *     target: { id: string }
        *     layoutOnly: boolean -- link exists only in layout (instead of underlying data)
        *
        * Events:
        *     state:loaded
        */
    export class Link extends joint.dia.Link {
            arrowheadMarkup: string;
            readonly markup: string;
            typeIndex: number;
            readonly typeId: string;
            readonly sourceId: string;
            readonly targetId: string;
            layoutOnly: boolean;
            initialize(attributes?: {
                    id: string;
            }): void;
    }
    export function linkMarkerKey(linkTypeIndex: number, startMarker: boolean): string;
    /**
        * Properties:
        *     visible: boolean
        *     showLabel: boolean
        *     isNew?: boolean
        *     label?: { values: LocalizedString[] }
        */
    export class FatLinkType extends Backbone.Model {
            readonly index: number;
            label: {
                    values: LocalizedString[];
            };
            readonly visible: boolean;
            setVisibility(params: {
                    visible: boolean;
                    showLabel: boolean;
            }, options?: PreventLinksLoading): void;
            constructor(params: {
                    id: string;
                    index: number;
                    label: {
                            values: LocalizedString[];
                    };
                    diagram: DiagramModel;
            });
    }
}

declare module 'ontodia/ontodia/diagram/layoutData' {
    export interface LayoutData {
        readonly cells: LayoutCell[];
    }
    export type LayoutCell = LayoutElement | LayoutLink;
    export interface LayoutElement {
        type: 'element';
        id: string;
        position: {
            x: number;
            y: number;
        };
        size?: any;
        angle?: number;
        isExpanded?: boolean;
    }
    export interface LayoutLink {
        type: 'link';
        id: string;
        typeId: string;
        source: {
            id: string;
        };
        target: {
            id: string;
        };
        vertices?: Array<{
            x: number;
            y: number;
        }>;
    }
    export function normalizeImportedCell<Cell extends LayoutCell>(cell: Cell): Cell;
    export function cleanExportedLayout(layout: LayoutData): LayoutData;
}

declare module 'ontodia/ontodia/diagram/model' {
    import * as Backbone from 'backbone';
    import * as joint from 'jointjs';
    import { Dictionary, LocalizedString, ElementModel, LinkModel } from 'ontodia/ontodia/data/model';
    import { DataProvider } from 'ontodia/ontodia/data/provider';
    import { LayoutData } from 'ontodia/ontodia/diagram/layoutData';
    import { Element, Link, FatLinkType, FatClassModel, RichProperty } from 'ontodia/ontodia/diagram/elements';
    export type IgnoreCommandHistory = {
        ignoreCommandManager?: boolean;
    };
    export type PreventLinksLoading = {
        preventLoading?: boolean;
    };
    /**
      * Model of diagram.
      *
      * Properties:
      *     isViewOnly: boolean
      *
      * Events:
      *     state:beginLoad
      *     state:endLoad (diagramElementCount?: number)
      *     state:loadError (error: any)
      *     state:renderStart
      *     state:renderDone
      *     state:dataLoaded
      *
      *     history:undo
      *     history:redo
      *     history:reset
      *     history:initBatchCommand
      *     history:storeBatchCommand
      */
    export class DiagramModel extends Backbone.Model {
        graph: joint.dia.Graph;
        dataProvider: DataProvider;
        classTree: ClassTreeElement[];
        constructor(isViewOnly?: boolean);
        isViewOnly(): boolean;
        readonly cells: Backbone.Collection<joint.dia.Cell>;
        readonly elements: Element[];
        readonly links: Link[];
        getElement(elementId: string): Element | undefined;
        getLinkType(linkTypeId: string): FatLinkType | undefined;
        linksOfType(linkTypeId: string): ReadonlyArray<Link>;
        sourceOf(link: Link): Element;
        targetOf(link: Link): Element;
        isSourceAndTargetVisible(link: Link): boolean;
        undo(): void;
        redo(): void;
        resetHistory(): void;
        initBatchCommand(): void;
        storeBatchCommand(): void;
        createNewDiagram(dataProvider: DataProvider): Promise<void>;
        importLayout(params: {
            dataProvider: DataProvider;
            preloadedElements?: Dictionary<ElementModel>;
            layoutData?: LayoutData;
            validateLinks?: boolean;
            linkSettings?: LinkTypeOptions[];
            hideUnusedLinkTypes?: boolean;
        }): Promise<void>;
        exportLayout(): {
            layoutData: LayoutData;
            linkSettings: LinkTypeOptions[];
        };
        createElement(idOrModel: string | ElementModel): Element;
        requestElementData(elements: Element[]): Promise<void> | Promise<any[]>;
        requestLinksOfType(linkTypeIds?: string[]): Promise<void>;
        getPropertyById(labelId: string): RichProperty;
        getClassesById(typeId: string): FatClassModel;
        createLinkType(linkTypeId: string): FatLinkType;
        createLink(linkModel: LinkModel & {
            suggestedId?: string;
            vertices?: Array<{
                x: number;
                y: number;
            }>;
        }, options?: IgnoreCommandHistory): Link | undefined;
        getLink(linkModel: LinkModel): Link | undefined;
    }
    export default DiagramModel;
    export interface ClassTreeElement {
        id: string;
        label: {
            values: LocalizedString[];
        };
        count: number;
        children: ClassTreeElement[];
        a_attr?: {
            href: string;
            draggable: boolean;
        };
    }
    export interface LinkTypeOptions {
        id: string;
        visible: boolean;
        showLabel?: boolean;
    }
    export function uri2name(uri: string): string;
    export function chooseLocalizedText(texts: LocalizedString[], language: string): LocalizedString;
}

declare module 'ontodia/ontodia/diagram/view' {
    import * as Backbone from 'backbone';
    import * as joint from 'jointjs';
    import { TypeStyleResolver, LinkStyleResolver, TemplateResolver, ElementTemplate, LinkStyle } from 'ontodia/ontodia/customization/props';
    import { Halo } from 'ontodia/ontodia/viewUtils/halo';
    import { ConnectionsMenu } from 'ontodia/ontodia/viewUtils/connectionsMenu';
    import { ToDataURLOptions } from 'ontodia/ontodia/viewUtils/toSvg';
    import { ElementModel, LocalizedString } from 'ontodia/ontodia/data/model';
    import { DiagramModel } from 'ontodia/ontodia/diagram/model';
    import { Element, FatClassModel } from 'ontodia/ontodia/diagram/elements';
    export interface DiagramViewOptions {
        typeStyleResolvers?: TypeStyleResolver[];
        linkStyleResolvers?: LinkStyleResolver[];
        templatesResolvers?: TemplateResolver[];
        disableDefaultHalo?: boolean;
    }
    export interface TypeStyle {
        color: {
            h: number;
            c: number;
            l: number;
        };
        icon?: string;
    }
    /**
      * Properties:
      *     language: string
      *
      * Events:
      *     (private) dispose - fires on view dispose
      */
    export class DiagramView extends Backbone.Model {
        readonly model: DiagramModel;
        readonly options: DiagramViewOptions;
        paper: joint.dia.Paper;
        halo: Halo;
        connectionsMenu: ConnectionsMenu;
        readonly selection: Backbone.Collection<Element>;
        constructor(model: DiagramModel, options?: DiagramViewOptions);
        getLanguage(): string;
        setLanguage(value: string): void;
        cancelSelection(): void;
        print(): void;
        exportSVG(): Promise<string>;
        exportPNG(options?: ToDataURLOptions): Promise<string>;
        adjustPaper(): void;
        initializePaperComponents(): void;
        showNavigationMenu(element: Element): void;
        hideNavigationMenu(): void;
        onDragDrop(e: DragEvent, paperPosition: {
            x: number;
            y: number;
        }): void;
        getLocalizedText(texts: LocalizedString[]): LocalizedString;
        getElementTypeString(elementModel: ElementModel): string;
        getElementTypeLabel(type: FatClassModel): LocalizedString;
        getLinkLabel(linkTypeId: string): LocalizedString;
        getTypeStyle(types: string[]): TypeStyle;
        registerElementStyleResolver(resolver: TypeStyleResolver): TypeStyleResolver;
        unregisterElementStyleResolver(resolver: TypeStyleResolver): TypeStyleResolver;
        getElementTemplate(types: string[]): ElementTemplate;
        registerTemplateResolver(resolver: TemplateResolver): TemplateResolver;
        unregisterTemplateResolver(resolver: TemplateResolver): TemplateResolver;
        getLinkStyle(linkTypeId: string): LinkStyle;
        registerLinkStyleResolver(resolver: LinkStyleResolver): LinkStyleResolver;
        unregisterLinkStyleResolver(resolver: LinkStyleResolver): LinkStyleResolver;
        getOptions(): DiagramViewOptions;
        dispose(): void;
    }
    export default DiagramView;
}

declare module 'ontodia/ontodia/workspace/workspace' {
    import { Component, ReactElement } from 'react';
    import { DiagramModel } from 'ontodia/ontodia/diagram/model';
    import { DiagramView, DiagramViewOptions } from 'ontodia/ontodia/diagram/view';
    import { SearchCriteria } from 'ontodia/ontodia/widgets/instancesSearch';
    export interface Props {
        onSaveDiagram?: (workspace: Workspace) => void;
        onShareDiagram?: (workspace: Workspace) => void;
        onEditAtMainSite?: (workspace: Workspace) => void;
        isViewOnly?: boolean;
        isDiagramSaved?: boolean;
        hideTutorial?: boolean;
        viewOptions?: DiagramViewOptions;
    }
    export interface State {
        readonly criteria?: SearchCriteria;
    }
    export class Workspace extends Component<Props, State> {
        static readonly defaultProps: {
            [K in keyof Props]?: any;
        };
        constructor(props: Props);
        render(): ReactElement<any>;
        componentDidMount(): void;
        componentWillUnmount(): void;
        getModel(): DiagramModel;
        getDiagram(): DiagramView;
        preventTextSelectionUntilMouseUp(): void;
        zoomToFit: () => void;
        showWaitIndicatorWhile(promise: Promise<any>): void;
        forceLayout: () => void;
        exportSvg: (link: HTMLAnchorElement) => void;
        exportPng: (link: HTMLAnchorElement) => void;
        undo: () => void;
        redo: () => void;
        zoomIn: () => void;
        zoomOut: () => void;
        print: () => void;
        changeLanguage: (language: string) => void;
    }
    export default Workspace;
}

declare module 'ontodia/ontodia/viewUtils/halo' {
    import * as joint from 'jointjs';
    import * as React from 'react';
    import { DiagramView } from 'ontodia/ontodia/diagram/view';
    export interface Props {
        paper: joint.dia.Paper;
        cellView: joint.dia.CellView;
        diagramView: DiagramView;
        onDelete?: () => void;
        onExpand?: () => void;
        navigationMenuOpened?: boolean;
        onToggleNavigationMenu?: () => void;
        onAddToFilter?: () => void;
    }
    export class Halo extends React.Component<Props, void> {
        componentWillMount(): void;
        componentWillReceiveProps(nextProps: Props): void;
        listenToCell(cellView: joint.dia.CellView): void;
        componentWillUnmount(): void;
        render(): JSX.Element;
    }
}

declare module 'ontodia/ontodia/viewUtils/connectionsMenu' {
    import * as joint from 'jointjs';
    import DiagramView from 'ontodia/ontodia/diagram/view';
    import { ElementModel } from 'ontodia/ontodia/data/model';
    export interface ReactElementModel {
        model: ElementModel;
        presentOnDiagram: boolean;
    }
    export interface ConnectionsMenuOptions {
        paper: joint.dia.Paper;
        view: DiagramView;
        cellView: joint.dia.CellView;
        onClose: () => void;
    }
    export class ConnectionsMenu {
        cellView: joint.dia.CellView;
        constructor(options: ConnectionsMenuOptions);
        remove(): void;
    }
}

declare module 'ontodia/ontodia/viewUtils/toSvg' {
    import * as joint from 'jointjs';
    export interface ToSVGOptions {
            preserveDimensions?: boolean;
            convertImagesToDataUris?: boolean;
            blacklistedCssAttributes?: string[];
            elementsToRemoveSelector?: string;
    }
    export function toSVG(paper: joint.dia.Paper, opt?: ToSVGOptions): Promise<string>;
    export interface ToDataURLOptions {
            /** 'image/png' | 'image/jpeg' | ... */
            type?: string;
            width?: number;
            height?: number;
            padding?: number;
            backgroundColor?: string;
            quality?: number;
            svgOptions?: ToSVGOptions;
    }
    export function toDataURL(paper: joint.dia.Paper, options?: ToDataURLOptions): Promise<string>;
    export function fitRectKeepingAspectRatio(sourceWidth: number, sourceHeight: number, targetWidth: number, targetHeight: number): {
            width: number;
            height: number;
    };
    /**
         * Creates and returns a blob from a data URL (either base64 encoded or not).
         *
         * @param {string} dataURL The data URL to convert.
         * @return {Blob} A blob representing the array buffer data.
         */
    export function dataURLToBlob(dataURL: string): Blob;
}

declare module 'ontodia/ontodia/widgets/instancesSearch' {
    import * as React from 'react';
    import { Dictionary, ElementModel } from 'ontodia/ontodia/data/model';
    import { DiagramView } from 'ontodia/ontodia/diagram/view';
    export interface InstancesSearchProps {
        className?: string;
        view: DiagramView;
        criteria: SearchCriteria;
        onCriteriaChanged: (criteria: SearchCriteria) => void;
    }
    export interface SearchCriteria {
        readonly text?: string;
        readonly elementTypeId?: string;
        readonly refElementId?: string;
        readonly refElementLinkId?: string;
        readonly linkDirection?: 'in' | 'out';
    }
    export interface State {
        readonly inputText?: string;
        readonly quering?: boolean;
        readonly resultId?: number;
        readonly error?: any;
        readonly items?: ReadonlyArray<ElementModel>;
        readonly moreItemsAvailable?: boolean;
        readonly selectedItems?: Readonly<Dictionary<boolean>>;
    }
    export class InstancesSearch extends React.Component<InstancesSearchProps, State> {
        constructor(props: InstancesSearchProps);
        render(): JSX.Element;
        componentDidMount(): void;
        componentWillReceiveProps(nextProps: InstancesSearchProps): void;
        componentWillUnmount(): void;
    }
}

